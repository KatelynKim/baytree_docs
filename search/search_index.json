{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Baytree App Developer Guide This is the developer guide to get you started on developing Baytree App. Getting Started Run Using Docker Setup Install Docker Create a file named .env (for environment variables) in the same directory as docker-compose.yml : SECRET_KEY=something_random MYSQL_USER=dbuser MYSQL_PASSWORD=something_random EMAIL_HOST=smtp.gmail.com EMAIL_PORT=587 EMAIL_USER=the_account@gmail.com EMAIL_PASSWORD=the_password VIEWS_USERNAME=the_username VIEWS_PASSWORD=the_password CELERY_BROKER_URL=redis://redis:6379 CELERY_RESULT_BACKEND=redis://redis:6379 AWS_ACCESS_KEY_ID= {your_id} AWS_SECRET_ACCESS_KEY= {your_key} AWS_DEFAULT_REGION= us-east-1 GRAFANA_LOGGING_URL=logs-prod3.grafana.net GRAFANA_USER=319402 GRAFANA_API_KEY={your_Grafana_API_key} MOCK_MYSQL_DATABASE=views_mock_db VIEWS_BASE_URL={base_url_for_views_apis} Install frontend dependencies (if running in Docker - see frontend section if not): bash docker compose run --rm frontend npm install docker compose run --rm admin-frontend npm install You need to build the docker compose first or when you updated the dependencies bash docker compose build Then, run the application: bash docker compose up Run migrations and create a superuser (while the application is running): bash docker exec baytree_server python manage.py migrate docker exec views-mock python manage.py migrate docker exec -it baytree_server python manage.py createsuperuser Run Locally To run the entire application: docker compose up To run only the backend + database: docker compose up server If new backend packages have been installed, run docker compose build prior to running the up commands above If new frontend packages have been installed, run the following prior to running the up commands above: bash docker compose run --rm frontend npm install docker compose run --rm admin-frontend npm install Commands Inside Container If you want to open a terminal within a container, use the command: docker exec -it [container-name] bash Migrations After a model change, run the following to make database migrations: docker exec <baytree_server/views-mock> python manage.py makemigrations To migrate your database, either because you or someone else made database migrations, run: docker exec <baytree_server/views-mock> python manage.py migrate Creating a User You can create a super (admin) user by running: docker exec -it baytree_server python manage.py createsuperuser Frontends Install Frontend Packages Run these commands to manage the depenedencies for containers baytree_frontend and baytree_admin_frontend Install packages as build dependenency, with the application running: ```bash docker exec [container_name] npm install [package_1] [package_2] ... # Shorthand syntax docker exec [container_name] npm i [package_1] [package_2] ... ``` Install packages as a develeper dependency, run the commands above with --save-dev tag: ```bash docker exec [container_name] npm install --save-dev [package_1] [package_2] ... # Shorthand syntax docker exec [container_name] npm i -D [package_1] [package_2] ... ``` Unistall a package, with the application running bash docker exec [container_name] npm uninstall [package_1] [package_2] ... Run Outside of Docker The frontends can either be run in Docker (using the instructions above) or outside of Docker. Due to the large number of files in node_modules , file system performance may be better outside of Docker. To run outside of Docker: Install Node.js Run npm install in both frontend folders Use the command docker compose up server to run only the backend + database Use the command docker compose up views-mock to run the node server for mocking Views APIs. Use the following commands to run the frontends: frontend: npm start admin-frontend: npm run dev Admin Portal Navigate to http://localhost:3001/admin in your browser and use your superuser credentials (or any admin user credentials) to log in","title":"Overview"},{"location":"#baytree-app-developer-guide","text":"This is the developer guide to get you started on developing Baytree App.","title":"Baytree App Developer Guide"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#run-using-docker","text":"","title":"Run Using Docker"},{"location":"#setup","text":"Install Docker Create a file named .env (for environment variables) in the same directory as docker-compose.yml : SECRET_KEY=something_random MYSQL_USER=dbuser MYSQL_PASSWORD=something_random EMAIL_HOST=smtp.gmail.com EMAIL_PORT=587 EMAIL_USER=the_account@gmail.com EMAIL_PASSWORD=the_password VIEWS_USERNAME=the_username VIEWS_PASSWORD=the_password CELERY_BROKER_URL=redis://redis:6379 CELERY_RESULT_BACKEND=redis://redis:6379 AWS_ACCESS_KEY_ID= {your_id} AWS_SECRET_ACCESS_KEY= {your_key} AWS_DEFAULT_REGION= us-east-1 GRAFANA_LOGGING_URL=logs-prod3.grafana.net GRAFANA_USER=319402 GRAFANA_API_KEY={your_Grafana_API_key} MOCK_MYSQL_DATABASE=views_mock_db VIEWS_BASE_URL={base_url_for_views_apis} Install frontend dependencies (if running in Docker - see frontend section if not): bash docker compose run --rm frontend npm install docker compose run --rm admin-frontend npm install You need to build the docker compose first or when you updated the dependencies bash docker compose build Then, run the application: bash docker compose up Run migrations and create a superuser (while the application is running): bash docker exec baytree_server python manage.py migrate docker exec views-mock python manage.py migrate docker exec -it baytree_server python manage.py createsuperuser","title":"Setup"},{"location":"#run-locally","text":"To run the entire application: docker compose up To run only the backend + database: docker compose up server If new backend packages have been installed, run docker compose build prior to running the up commands above If new frontend packages have been installed, run the following prior to running the up commands above: bash docker compose run --rm frontend npm install docker compose run --rm admin-frontend npm install","title":"Run Locally"},{"location":"#commands-inside-container","text":"If you want to open a terminal within a container, use the command: docker exec -it [container-name] bash","title":"Commands Inside Container"},{"location":"#migrations","text":"After a model change, run the following to make database migrations: docker exec <baytree_server/views-mock> python manage.py makemigrations To migrate your database, either because you or someone else made database migrations, run: docker exec <baytree_server/views-mock> python manage.py migrate","title":"Migrations"},{"location":"#creating-a-user","text":"You can create a super (admin) user by running: docker exec -it baytree_server python manage.py createsuperuser","title":"Creating a User"},{"location":"#frontends","text":"","title":"Frontends"},{"location":"#install-frontend-packages","text":"Run these commands to manage the depenedencies for containers baytree_frontend and baytree_admin_frontend Install packages as build dependenency, with the application running: ```bash docker exec [container_name] npm install [package_1] [package_2] ... # Shorthand syntax docker exec [container_name] npm i [package_1] [package_2] ... ``` Install packages as a develeper dependency, run the commands above with --save-dev tag: ```bash docker exec [container_name] npm install --save-dev [package_1] [package_2] ... # Shorthand syntax docker exec [container_name] npm i -D [package_1] [package_2] ... ``` Unistall a package, with the application running bash docker exec [container_name] npm uninstall [package_1] [package_2] ...","title":"Install Frontend Packages"},{"location":"#run-outside-of-docker","text":"The frontends can either be run in Docker (using the instructions above) or outside of Docker. Due to the large number of files in node_modules , file system performance may be better outside of Docker. To run outside of Docker: Install Node.js Run npm install in both frontend folders Use the command docker compose up server to run only the backend + database Use the command docker compose up views-mock to run the node server for mocking Views APIs. Use the following commands to run the frontends: frontend: npm start admin-frontend: npm run dev","title":"Run Outside of Docker"},{"location":"#admin-portal","text":"Navigate to http://localhost:3001/admin in your browser and use your superuser credentials (or any admin user credentials) to log in","title":"Admin Portal"},{"location":"future/","text":"Future work - What's left? Mock the remaining Views endpoints in baytree_app The following Views endpoints need to be mocked: Baytree view Views endpoint mentor-mentees contacts/staff/{id}/associations session-group work/sessiongroups sessions work/sessiongroups/sessions questionnaires/answers/submit evidence/questionnaires/{qid}/answers Resolve all linting errors in admin-frontend Because linting had not been enforced until later in the development cycle, hundreds of linting errors accmumulated throughout frontend and admin-frontend over the last couple of years. While we have resolved all errors in frontend , there are still 180+ linting errors remaining in admin-frontend . Run npm run lint to view these errors. Convert Baytree views from synchronous to asynchronous All endpoints under baytree_app/views-api are currently implemented as synchronous, except for the get_participants endpoint. This synchronous implementation could create performance issues in the backend. With synchronous endpoints, the server has to process one request at a time, blocking other requests until the current request is completed. This can result in longer response times and slower performance. To address this issue, converting all the synchronous endpoints to asynchronous can significantly improve performance. Asynchronous endpoints allow the server to process multiple requests simultaneously, reducing response times and improving performance. get_participants endpoint serves as an example for how to implement an asynchronous endpoint (the endpoint was converted from sync to async in this MR ). In addition to adding the async keyword, we use aiohttp 's ClientSession to make an asynchronous request. Additional note: baytree_app has several functions join data queried from the local MySQL database with the data fetched using a Views API. One example is JointMentorsAndVolunteersData views in views_api/volunteers.py (shown below). The view makes a request to /contacts/volunteers by calling the get_volunteers endpoint to fetch volunteers from Views and queries mentor objects from the local database. The two datasets are then joined on the ID field. Here, it is easy to assume that JointMentorsAndVolunteersData will behave asynchronously once we add async keyword to view's get method, and convert get_volunteers to an asynchronous endpoint, similar to what we did for get_participants . However, doing so is not enough and will lead to an error since querying the database is not asynchronous. As we cannot await MentorUser.object.all() , mentors_from_db passed into join_views_volunteers_to_mentors_users will be None. To support a synchronous implementation of this endpoint, further steps to make database queries asynchronous are necessary. class JointMentorsAndVolunteersData(APIView): def get(self, request): ... mentors_from_db = MentorUser.objects.all() // Queries MentorUser objects from the local database response = get_volunteers(updated_request) // Fetches volunteers from Views joined_data = join_views_volunteers_to_mentor_users( // Joins the two datasets on the ID field. mentors_from_db, response.data[\"data\"] ) ... return Response({ \"count\": len(joined_data), \"results\": joined_data }) Add fixtures data To streamline the testing process for our mocked endpoints, we can explore the use of Django fixtures to load initial data to the database. This would eliminate the need for developers to manually add mock data to the appropriate tables in the correct order based on foreign key relationships, which can be a tedious and error-prone process, especially if the database container needs to be destroyed and rebuilt. By using fixtures, we can provide pre-defined data in a structured format, such as JSON, YAML or XML files, which can be easily loaded into the database using Django's built-in loaddata command. This would make it simpler for developers to set up the necessary data for testing our mocked endpoints. Note that the fixtures would still have to be loaded in the correct order to satisfy the existing foreign key relationships. Using Django fixtures to load initial data to the database can improve the efficiency and accuracy of our testing process, and it is a good practice to consider for future development. Add unit tests At the moment, the backend does not have any unit tests, which has resulted in uncertainty about whether newly introduced code or refactoring will break existing features. This issue has caused problems during the current development cycle, where modifications to an existing functionality were confirmed to work correctly, only to find out later that they actually broke another functionality. To address this issue, we need to implement unit tests for the backend. Unit tests serve as a safety net, alerting us to breaking changes and reducing the need for manual testing. With unit tests in place, we can catch any regressions or issues quickly and prevent them from making their way to production.","title":"Future work"},{"location":"future/#future-work-whats-left","text":"","title":"Future work - What's left?"},{"location":"future/#mock-the-remaining-views-endpoints-in-baytree_app","text":"The following Views endpoints need to be mocked: Baytree view Views endpoint mentor-mentees contacts/staff/{id}/associations session-group work/sessiongroups sessions work/sessiongroups/sessions questionnaires/answers/submit evidence/questionnaires/{qid}/answers","title":"Mock the remaining Views endpoints in baytree_app"},{"location":"future/#resolve-all-linting-errors-in-admin-frontend","text":"Because linting had not been enforced until later in the development cycle, hundreds of linting errors accmumulated throughout frontend and admin-frontend over the last couple of years. While we have resolved all errors in frontend , there are still 180+ linting errors remaining in admin-frontend . Run npm run lint to view these errors.","title":"Resolve all linting errors in admin-frontend"},{"location":"future/#convert-baytree-views-from-synchronous-to-asynchronous","text":"All endpoints under baytree_app/views-api are currently implemented as synchronous, except for the get_participants endpoint. This synchronous implementation could create performance issues in the backend. With synchronous endpoints, the server has to process one request at a time, blocking other requests until the current request is completed. This can result in longer response times and slower performance. To address this issue, converting all the synchronous endpoints to asynchronous can significantly improve performance. Asynchronous endpoints allow the server to process multiple requests simultaneously, reducing response times and improving performance. get_participants endpoint serves as an example for how to implement an asynchronous endpoint (the endpoint was converted from sync to async in this MR ). In addition to adding the async keyword, we use aiohttp 's ClientSession to make an asynchronous request.","title":"Convert Baytree views from synchronous to asynchronous"},{"location":"future/#additional-note","text":"baytree_app has several functions join data queried from the local MySQL database with the data fetched using a Views API. One example is JointMentorsAndVolunteersData views in views_api/volunteers.py (shown below). The view makes a request to /contacts/volunteers by calling the get_volunteers endpoint to fetch volunteers from Views and queries mentor objects from the local database. The two datasets are then joined on the ID field. Here, it is easy to assume that JointMentorsAndVolunteersData will behave asynchronously once we add async keyword to view's get method, and convert get_volunteers to an asynchronous endpoint, similar to what we did for get_participants . However, doing so is not enough and will lead to an error since querying the database is not asynchronous. As we cannot await MentorUser.object.all() , mentors_from_db passed into join_views_volunteers_to_mentors_users will be None. To support a synchronous implementation of this endpoint, further steps to make database queries asynchronous are necessary. class JointMentorsAndVolunteersData(APIView): def get(self, request): ... mentors_from_db = MentorUser.objects.all() // Queries MentorUser objects from the local database response = get_volunteers(updated_request) // Fetches volunteers from Views joined_data = join_views_volunteers_to_mentor_users( // Joins the two datasets on the ID field. mentors_from_db, response.data[\"data\"] ) ... return Response({ \"count\": len(joined_data), \"results\": joined_data })","title":"Additional note:"},{"location":"future/#add-fixtures-data","text":"To streamline the testing process for our mocked endpoints, we can explore the use of Django fixtures to load initial data to the database. This would eliminate the need for developers to manually add mock data to the appropriate tables in the correct order based on foreign key relationships, which can be a tedious and error-prone process, especially if the database container needs to be destroyed and rebuilt. By using fixtures, we can provide pre-defined data in a structured format, such as JSON, YAML or XML files, which can be easily loaded into the database using Django's built-in loaddata command. This would make it simpler for developers to set up the necessary data for testing our mocked endpoints. Note that the fixtures would still have to be loaded in the correct order to satisfy the existing foreign key relationships. Using Django fixtures to load initial data to the database can improve the efficiency and accuracy of our testing process, and it is a good practice to consider for future development.","title":"Add fixtures data"},{"location":"future/#add-unit-tests","text":"At the moment, the backend does not have any unit tests, which has resulted in uncertainty about whether newly introduced code or refactoring will break existing features. This issue has caused problems during the current development cycle, where modifications to an existing functionality were confirmed to work correctly, only to find out later that they actually broke another functionality. To address this issue, we need to implement unit tests for the backend. Unit tests serve as a safety net, alerting us to breaking changes and reducing the need for manual testing. With unit tests in place, we can catch any regressions or issues quickly and prevent them from making their way to production.","title":"Add unit tests"},{"location":"mock_views/","text":"Mock Views What is Mock Views? Mock Views is a mock system designed for Views App , a third-party data management tool used by the Baytree Organization to manage data related to staff, mentors, mentees, sessions, session groups, and more. Mock Views was developed to allow Baytree App to continue functioning without access to Views App. Views App provides REST API services that support CRUD operations on these data. Baytree App uses a subset of these APIs for its features. Mock Views replicates these APIs, allowing users to perform the same CRUD operations on their data stored in views_mock_db , a mock database that mimics the structure of Views App's database. Just like Views App, Mock Views returns the requested data in an XML or JSON format in addition to adding, updating, and deleting data in views_mock_db . Note that the tables in views_mock_db contain only the fields that are used in baytree_app . Project structure Mock Views is implemented using Django, just like the Baytree server. It contains the following apps, each with a migration folder storing migration files and models.py to define data models: * admin_valuelists * contacts * evidence * views_sessions Mocked endpoints can be found inside the views_api directory. Endpoints are defined in these files: contacts.py , valuelists.py , and questionnaires.py . Views Mock Database Views Mock Database ( views_mock_db ) is a MySQL database that mimics the database schemas for Views App. It runs on the same port as the baytree database. It is created by running python manage.py createdb at the time of creating the views-mock container. Note that you must add the following environment variable for successful mock database creation: MOCK_MYSQL_DATABASE=views_mock_db . Authentication ViewsAuthMiddleware intercepts any requests with paths that start with /api/views-api to attach a VIEWS_AUTHORIZATION header. If the VIEWS_BASE_URL environment variable in the .env file is set to the base URL for Views App ( https://app.viewsapp.net/api/restful/ ), the VIEWS_AUTHORIZATION header is populated with the base64-encoded string value of the VIEWS_USER_NAME and VIEWS_PASSWORD environment variables. If VIEWS_BASE_URL is set to the base URL of Mock Views ( http://views-mock:5001/ ), the VIEWS_AUTHORIZATION header is set to the currently active access_token . Shared Apps shared-apps contain users and sessions apps, which include models.py files defining user and session models. These models are shared between baytree_app and views_mock as both projects need the models for checking user permissions for a given request. To learn how this sharable app was created, check Django's official documentation . Mock APIs This section summarizes all of the mocked Views APIs used by baytree_app . Param (Baytree) lists the query parameters that are set by the client and accessed by baytree_app . Param (Views Mock) lists the query parameters that are set by baytree_app and accessed by views_mock . To test the response returned by the baytree_app , make a request to http://localhost:8000/views_api/{path-to-your-view} using the query parameters under Param (Baytree) . Requests to baytree_app 's Views endpoints will return parsed results. To test the response returned by views_mock , make a request to http://localhost:5001/views_api/{path-to-your-view} using the query parameters under Param (Views Mock) . Requests to views_mock 's Views endpoints will return raw XML or JSON results. Contacts /contacts/participants/search Fetches participants in an XML format. Param (Baytree) Param (Views Mock) Description Type id PersonID Participant ID Number pageFold pageFold Number of results to return in a result set Number limit offset Number of results to offset in a result set Number <root> <contacts/> <participants count=\"2\"/> <participant id=\"1\"/> <PersonID/> 1 </PersonID/> <Forename/> Amber </Forename/> <Surname/> Smith </Surname/> <TypeName/> participant </TypeName/> <Email/> amber_smith@sfu.ca </Email/> <DateOfBirth/> 1994-01-01 </DateOfBirth/> <FirstLanguage_P_88/> English </FirstLanguage_P_88/> <Ethnicity/> American </Ethnicity/> <Countryofbirth_P_87/> None </Countryofbirth_P_87/> </participant/> <participant id=\"2\"/> <PersonID/> 2 </PersonID/> ... </participant/> </participants/> </contacts/> </root> /contacts/volunteers/search Fetches volunteers in an XML format. Param (Baytree) Param (Views Mock) Description Type id PersonID Volunteer ID Number searchEmail Email Volunteer email String searchFirstName Forename Volunnter's first name String searchLastName Surname Volunteer's last name String limit pageFold Number of results to return in a result set Number offset offset Number of results to offset in a result set Number Sample response: <root> <contacts/> <volunteers count=\"2\"/> <volunteer id=\"3\"/> <PersonID/> 3 </PersonID/> <Forename/> John </Forename/> <Surname/> Park </Surname/> <TypeName/> volunteer </TypeName/> <Email/> None </Email/> <DateOfBirth/> 1994-01-01 </DateOfBirth/> <Whatisyourfirstlanguage_V_19/> English </Whatisyourfirstlanguage_V_19/> <Ethnicity_V_15/> Canadian </Ethnicity_V_15/> <County/> None</County/> </volunteer/> <volunteer id=\"4\"/> <PersonID/> 4 </PersonID/> ... </volunteer/> </volunteers/> </contacts/> </root> Evidence /evidence/questionnaires/{id} Fetches a questionnaire with the provided ID in a JSON format. Sample response: { \"QuestionnaireID\": \"1\", \"Title\": \"121 Session Questionnaire\", \"Description\": \"Standard questionnaire\", \"Created\": \"2023-04-13T00:00:00Z\", \"Updated\": \"2023-04-13T00:00:00Z\", \"CreatedBy\": \"Jonathan\", \"UpdatedBy\": \"Jonathan\", \"questions\": { \"1\": { \"QuestionID\": \"1\", \"Question\": \"How was this session conducted?\", \"valueListID\": 1, \"inputType\": \"textarea\", \"validation\": \"some\", \"category\": \"satisfaction\", \"enabled\": \"1\" }, \"2\": { \"QuestionID\": \"2\", \"Question\": \"Did you find the session useful?\", \"valueListID\": 1, \"inputType\": \"textarea\", \"validation\": \"validation\", \"category\": \"satisfaction\", \"enabled\": \"1\" } } } /evidence/questionnaire/search Fetches questionnaires in a JSON format. Param (Baytree) Param (Views Mock) Description Type id PersonID Participant ID Number title Title Number of results to offset in a result set String limit pageFold Number of results to return in a result set Number offset offset Number of results to offset in a result set Number Sample response: { \"questionnaires count=\\\"2\\\"\": { \"questionnaire id=\\\"1\\\"\": { \"QuestionnaireID\": \"1\", \"Title\": \"121 Session Questionnaire\", \"Description\": \"Standard questionnaire\", \"Created\": \"2023-04-13T00:00:00Z\", \"Updated\": \"2023-04-13T00:00:00Z\", \"CreatedBy\": \"Jonathan\", \"UpdatedBy\": \"Jonathan\" }, \"questionnaire id=\\\"2\\\"\": { \"QuestionnaireID\": \"2\", \"Title\": \"July Questionnaire\", \"Description\": \"Questionnaire for July\", \"Created\": \"2023-01-02T00:00:00Z\", \"Updated\": \"2023-02-20T00:00:00Z\", \"CreatedBy\": \"Katelyn\", \"UpdatedBy\": \"Katelyn\" } } } Admin /admin/valuelists/{id} Fetches a valuelist with the provided ID (number) in a JSON format. A valuelist is a list of values or options for a given question on a form. Sample response: { \"items\": { \"Yes\": \"Yes\", \"No\": \"No\" } } /admin/valuelists/{Type}/{Name} Fetches a valuelist with the provided type (string) and name (string) in a JSON format. Views supports querying a valuelist by its type and name. Type must be one of the following: Staff Volunteer Individual Person Group Session SessionGroup Question Agency Venue QualificationProgress QualificationAchievement AddressBook Report Name can be any user-defined values. Currently, baytree_app uses this endpoint for the following views: Baytree view Views endpoint get_activities_endpoint admin/valuelists/sessiongroup/agencyactivities get_venues_endpoint admin/valuelists/sessiongroup/venues get_volunteering_types_endpoint admin/valuelists/sessiongroup/volunteeringtypes Sample response: { \"items\": { \"Animal Care\": \"Animal Care\", \"Academic\": \"Academic\" } } To be implemented The following Baytree views need to be mocked: /session/session-groups /sessions questionnaires/answers/submit mentor-mentees","title":"Mock Views"},{"location":"mock_views/#mock-views","text":"","title":"Mock Views"},{"location":"mock_views/#what-is-mock-views","text":"Mock Views is a mock system designed for Views App , a third-party data management tool used by the Baytree Organization to manage data related to staff, mentors, mentees, sessions, session groups, and more. Mock Views was developed to allow Baytree App to continue functioning without access to Views App. Views App provides REST API services that support CRUD operations on these data. Baytree App uses a subset of these APIs for its features. Mock Views replicates these APIs, allowing users to perform the same CRUD operations on their data stored in views_mock_db , a mock database that mimics the structure of Views App's database. Just like Views App, Mock Views returns the requested data in an XML or JSON format in addition to adding, updating, and deleting data in views_mock_db . Note that the tables in views_mock_db contain only the fields that are used in baytree_app .","title":"What is Mock Views?"},{"location":"mock_views/#project-structure","text":"Mock Views is implemented using Django, just like the Baytree server. It contains the following apps, each with a migration folder storing migration files and models.py to define data models: * admin_valuelists * contacts * evidence * views_sessions Mocked endpoints can be found inside the views_api directory. Endpoints are defined in these files: contacts.py , valuelists.py , and questionnaires.py .","title":"Project structure"},{"location":"mock_views/#views-mock-database","text":"Views Mock Database ( views_mock_db ) is a MySQL database that mimics the database schemas for Views App. It runs on the same port as the baytree database. It is created by running python manage.py createdb at the time of creating the views-mock container. Note that you must add the following environment variable for successful mock database creation: MOCK_MYSQL_DATABASE=views_mock_db .","title":"Views Mock Database"},{"location":"mock_views/#authentication","text":"ViewsAuthMiddleware intercepts any requests with paths that start with /api/views-api to attach a VIEWS_AUTHORIZATION header. If the VIEWS_BASE_URL environment variable in the .env file is set to the base URL for Views App ( https://app.viewsapp.net/api/restful/ ), the VIEWS_AUTHORIZATION header is populated with the base64-encoded string value of the VIEWS_USER_NAME and VIEWS_PASSWORD environment variables. If VIEWS_BASE_URL is set to the base URL of Mock Views ( http://views-mock:5001/ ), the VIEWS_AUTHORIZATION header is set to the currently active access_token .","title":"Authentication"},{"location":"mock_views/#shared-apps","text":"shared-apps contain users and sessions apps, which include models.py files defining user and session models. These models are shared between baytree_app and views_mock as both projects need the models for checking user permissions for a given request. To learn how this sharable app was created, check Django's official documentation .","title":"Shared Apps"},{"location":"mock_views/#mock-apis","text":"This section summarizes all of the mocked Views APIs used by baytree_app . Param (Baytree) lists the query parameters that are set by the client and accessed by baytree_app . Param (Views Mock) lists the query parameters that are set by baytree_app and accessed by views_mock . To test the response returned by the baytree_app , make a request to http://localhost:8000/views_api/{path-to-your-view} using the query parameters under Param (Baytree) . Requests to baytree_app 's Views endpoints will return parsed results. To test the response returned by views_mock , make a request to http://localhost:5001/views_api/{path-to-your-view} using the query parameters under Param (Views Mock) . Requests to views_mock 's Views endpoints will return raw XML or JSON results.","title":"Mock APIs"},{"location":"mock_views/#contacts","text":"","title":"Contacts"},{"location":"mock_views/#contactsparticipantssearch","text":"Fetches participants in an XML format. Param (Baytree) Param (Views Mock) Description Type id PersonID Participant ID Number pageFold pageFold Number of results to return in a result set Number limit offset Number of results to offset in a result set Number <root> <contacts/> <participants count=\"2\"/> <participant id=\"1\"/> <PersonID/> 1 </PersonID/> <Forename/> Amber </Forename/> <Surname/> Smith </Surname/> <TypeName/> participant </TypeName/> <Email/> amber_smith@sfu.ca </Email/> <DateOfBirth/> 1994-01-01 </DateOfBirth/> <FirstLanguage_P_88/> English </FirstLanguage_P_88/> <Ethnicity/> American </Ethnicity/> <Countryofbirth_P_87/> None </Countryofbirth_P_87/> </participant/> <participant id=\"2\"/> <PersonID/> 2 </PersonID/> ... </participant/> </participants/> </contacts/> </root>","title":"/contacts/participants/search"},{"location":"mock_views/#contactsvolunteerssearch","text":"Fetches volunteers in an XML format. Param (Baytree) Param (Views Mock) Description Type id PersonID Volunteer ID Number searchEmail Email Volunteer email String searchFirstName Forename Volunnter's first name String searchLastName Surname Volunteer's last name String limit pageFold Number of results to return in a result set Number offset offset Number of results to offset in a result set Number Sample response: <root> <contacts/> <volunteers count=\"2\"/> <volunteer id=\"3\"/> <PersonID/> 3 </PersonID/> <Forename/> John </Forename/> <Surname/> Park </Surname/> <TypeName/> volunteer </TypeName/> <Email/> None </Email/> <DateOfBirth/> 1994-01-01 </DateOfBirth/> <Whatisyourfirstlanguage_V_19/> English </Whatisyourfirstlanguage_V_19/> <Ethnicity_V_15/> Canadian </Ethnicity_V_15/> <County/> None</County/> </volunteer/> <volunteer id=\"4\"/> <PersonID/> 4 </PersonID/> ... </volunteer/> </volunteers/> </contacts/> </root>","title":"/contacts/volunteers/search"},{"location":"mock_views/#evidence","text":"","title":"Evidence"},{"location":"mock_views/#evidencequestionnairesid","text":"Fetches a questionnaire with the provided ID in a JSON format. Sample response: { \"QuestionnaireID\": \"1\", \"Title\": \"121 Session Questionnaire\", \"Description\": \"Standard questionnaire\", \"Created\": \"2023-04-13T00:00:00Z\", \"Updated\": \"2023-04-13T00:00:00Z\", \"CreatedBy\": \"Jonathan\", \"UpdatedBy\": \"Jonathan\", \"questions\": { \"1\": { \"QuestionID\": \"1\", \"Question\": \"How was this session conducted?\", \"valueListID\": 1, \"inputType\": \"textarea\", \"validation\": \"some\", \"category\": \"satisfaction\", \"enabled\": \"1\" }, \"2\": { \"QuestionID\": \"2\", \"Question\": \"Did you find the session useful?\", \"valueListID\": 1, \"inputType\": \"textarea\", \"validation\": \"validation\", \"category\": \"satisfaction\", \"enabled\": \"1\" } } }","title":"/evidence/questionnaires/{id}"},{"location":"mock_views/#evidencequestionnairesearch","text":"Fetches questionnaires in a JSON format. Param (Baytree) Param (Views Mock) Description Type id PersonID Participant ID Number title Title Number of results to offset in a result set String limit pageFold Number of results to return in a result set Number offset offset Number of results to offset in a result set Number Sample response: { \"questionnaires count=\\\"2\\\"\": { \"questionnaire id=\\\"1\\\"\": { \"QuestionnaireID\": \"1\", \"Title\": \"121 Session Questionnaire\", \"Description\": \"Standard questionnaire\", \"Created\": \"2023-04-13T00:00:00Z\", \"Updated\": \"2023-04-13T00:00:00Z\", \"CreatedBy\": \"Jonathan\", \"UpdatedBy\": \"Jonathan\" }, \"questionnaire id=\\\"2\\\"\": { \"QuestionnaireID\": \"2\", \"Title\": \"July Questionnaire\", \"Description\": \"Questionnaire for July\", \"Created\": \"2023-01-02T00:00:00Z\", \"Updated\": \"2023-02-20T00:00:00Z\", \"CreatedBy\": \"Katelyn\", \"UpdatedBy\": \"Katelyn\" } } }","title":"/evidence/questionnaire/search"},{"location":"mock_views/#admin","text":"","title":"Admin"},{"location":"mock_views/#adminvaluelistsid","text":"Fetches a valuelist with the provided ID (number) in a JSON format. A valuelist is a list of values or options for a given question on a form. Sample response: { \"items\": { \"Yes\": \"Yes\", \"No\": \"No\" } }","title":"/admin/valuelists/{id}"},{"location":"mock_views/#adminvalueliststypename","text":"Fetches a valuelist with the provided type (string) and name (string) in a JSON format. Views supports querying a valuelist by its type and name. Type must be one of the following: Staff Volunteer Individual Person Group Session SessionGroup Question Agency Venue QualificationProgress QualificationAchievement AddressBook Report Name can be any user-defined values. Currently, baytree_app uses this endpoint for the following views: Baytree view Views endpoint get_activities_endpoint admin/valuelists/sessiongroup/agencyactivities get_venues_endpoint admin/valuelists/sessiongroup/venues get_volunteering_types_endpoint admin/valuelists/sessiongroup/volunteeringtypes Sample response: { \"items\": { \"Animal Care\": \"Animal Care\", \"Academic\": \"Academic\" } }","title":"/admin/valuelists/{Type}/{Name}"},{"location":"mock_views/#to-be-implemented","text":"The following Baytree views need to be mocked: /session/session-groups /sessions questionnaires/answers/submit mentor-mentees","title":"To be implemented"}]}